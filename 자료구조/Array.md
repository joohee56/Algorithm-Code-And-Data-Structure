## 배열(Array)
![image](https://github.com/joohee56/Algorithm-Code-And-Data-Structure/assets/83942393/8d8880af-da4f-481c-ae54-0b7cc6d24a86)

### 특징
* 데이터는 `인덱스(Index)` 번호와 일대일 대응 → `직접 접근(direct access)` / `임의 접근(random access)`
* `<인덱스, 요소>` 쌍의 집합
* `동일한 자료형`
* `연결리스트`와 대응 : 맨 처음부터 순차적 접근 → `순차 접근(sequential access)`
</br>

### 추상 자료형
```
객체 : <인덱스, 요소> 쌍의 집합
연산 :
- create(n) : n개의 요소를 가진 배열을 생성한다.
- retrieve(i) : 배열의 i번째 요소를 반환한다. 
- store(i, item) : 배열의 i번째 위치에 item을 저장한다. 
```
</br>

### 문자열: 특별한 1차원 배열
문자열은 1차원 배열의 한 종류로 `char`형의 요소를 갖는 배열을 의미한다.</br>     
</br>

## 배열 연산의 시간 복잡도
* 데이터에 접근하기 위한 시간 복잡도는 `O(1)`
* `추가`
    * 맨 뒤에 삽입할 경우 `O(1)`
    * 맨 앞에 삽입할 경우 `O(n)` : 기존 데이터들을 한 칸씩 밀어야 한다.
    * 중간에 삽입할 경우 `O(n)` : 삽입할 데이터 뒤에 있는 데이터들을 한 칸씩 밀어야 한다.
</br>

### JAVA ArrayList 시간복잡도
* add(e) : `O(1)` (맨뒤 삽입)
* add(i, e) : `O(n)` (중간 삽입)
* set(i, e) : `O(1)` (대체)
* remove(i) : `O(n)`
* remove(o) : `O(n)`
* get(i) : `O(1)`
* Contains(e) : `O(n)`
* iterator.remove : `O(n)`

**특징**
* 데이터 추가, 삭제를 위해 임시 배열을 생성해 데이터를 복사한다.
* 대량의 데이터를 추가/삭제 시 복사가 일어나 성능 저하를 일으킨다.
* 데이터의 인덱스를 가지고 있어 데이터 검색 시 빠르다.
</br>

### 결론
* 배열은 특정한 경우에 데이터를 추가나 삭제에 드는 비용이 크다. `따라서 중간에 데이터 삽입이 많은지 확인해야 한다.` 
* 데이터에 `자주 접근하거나 읽어야 하는 경우에 좋은 성능`을 낸다.
    * 예를 들어, 그래프를 표현할 때 배열을 활용하면 임의 접근을 할 수 있으므로 간선 여부 확인 시간 복잡도 `O(1)`로 판단할 수 있다.
* 메모리 공간을 충분히 확보해야 한다. `따라서 할당할 수 있는 메모리 크기를 확인해야 한다.`  
</br>
</br>



