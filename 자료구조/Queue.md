## 큐
<img src="https://github.com/joohee56/Algorithm-Code-And-Data-Structure/assets/83942393/51b9004f-77f2-4011-b58d-83b9d21c670c" width="50%"/>   

* `선입선출(FIFO: First-In First-Out)`
* 큐의 대표적인 예로는 은행에서 서비스를 기다리는 고객들이 한 줄로 늘어선 열을 들 수 있다.
* 큐에서 `삽입`이 일어나는 곳을 `후단(rear)`라고 하고 `삭제`가 일어나는 곳을 `전단(front)`라고 한다.
</br>

### 추상자료형 (ADT)
```
객체: 선입선출(FIFO)의 접근 방법을 유지하는 요소들의 모음
연산:
- enqueue(e): 주어진 요소 e를 큐의 맨 뒤에 추가한다.
- dequeue(): 큐가 비어 있지 않으면 맨 앞 요소를 삭제하고 반환한다.
- isEmpty(): 큐가 비어 있지 않으면 true를 아니면 false를 반환한다.
- peek(): 큐가 비어 있지 않으면 맨 앞 요소를 삭제하지 않고 반환한다.
- isFull(): 큐가 가득 차 있으면 true를 아니면 false를 반환한다.
```
</br>

### 큐의 활용
- 버퍼(buffer): 컴퓨터 장치들 사이에서 데이터를 주고 받을 때, 각 장치들 사이에 존재하는 속도나 시간의 차이를 극복하기 위한 임시 기억 장치
  - 키보드와 컴퓨터 사이의 큐(입력 버퍼)
  - CPU와 프린터 사이의 인쇄 작업 큐
  - 실시간 비디오 스트리밍에서의 버퍼링   
</br>

### 큐의 구현
* 선형 큐
  * front와 rear의 초기 값은 -1이다.
  * enqueue: rear를 하나 증가시키고 그 위치에 데이터를 저장한다. `O(1)`
  * dequeue: front를 하나 증기시키고 front가 가리키는 위치에 있는 요소를 삭제한다. O(1)
  * 문제점: front와 rear가 계속 증가만 하기 때문에 언젠가는 배열의 끝에 도달하게 되고, 배열의 앞부분이 비어 있더라도 더 이상 삽입하지 못한다. 따라서, 후단에 더 이상 삽입할 공간이 없으면 모든 요소들을 앞쪽으로 이동시킨다. 이 방법은 시간 복잡도가 O(n)이므로 비효율적이다. 따라서 원형 큐가 사용이 된다. 
* 원형 큐
